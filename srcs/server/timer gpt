Compris, vous souhaitez mettre en place un mécanisme qui vous permet de gérer un délai d'inactivité spécifique pour chaque connexion. Voici comment vous pourriez faire cela :

    Création d'une structure de données pour stocker les timers :
        Vous pouvez utiliser une structure pour chaque connexion active, associant un descripteur de fichier timer (timer_fd) à la connexion.

    cpp

struct Connection {
    int socket_fd;
    int timer_fd;
};

Création et configuration des timers pour chaque connexion :

    À chaque nouvelle connexion, vous créez un descripteur de fichier timer pour cette connexion spécifique.

cpp

Connection new_connection;
new_connection.socket_fd = /* ... */;
new_connection.timer_fd = timerfd_create(CLOCK_MONOTONIC, 0);

// Configuration du timer selon vos besoins
// (par exemple, timerfd_settime avec le délai d'inactivité souhaité)

Ajout des timers à l'événement epoll :

    Vous ajoutez à la fois le descripteur de fichier de la connexion et celui du timer à l'événement epoll.

cpp

struct epoll_event event;
event.events = EPOLLIN | EPOLLET; // Ajoutez d'autres événements selon vos besoins
event.data.ptr = &new_connection;

epoll_ctl(epoll_fd, EPOLL_CTL_ADD, new_connection.socket_fd, &event);
epoll_ctl(epoll_fd, EPOLL_CTL_ADD, new_connection.timer_fd, &event);

Dans la boucle principale avec epoll_wait :

    Vous traitez les événements reçus par epoll_wait.

cpp

while (true) {
    int num_events = epoll_wait(epoll_fd, events, MAX_EVENTS, -1);

    for (int i = 0; i < num_events; ++i) {
        Connection* conn = static_cast<Connection*>(events[i].data.ptr);

        if (events[i].events & EPOLLIN) {
            if (events[i].data.fd == conn->socket_fd) {
                // Lire les données de la connexion
            }
            else if (events[i].data.fd == conn->timer_fd) {
                // Le timer associé à cette connexion a expiré
                // Cela signifie que la connexion est inactive depuis le délai spécifié
                // Vous pouvez fermer la connexion ici
            }
        }

        // ... (autres événements à gérer)
    }
}

Mise à jour du timer lors de l'activité de la connexion :

    Chaque fois que vous recevez des données de la connexion, réinitialisez le timer associé à cette connexion pour éviter qu'il n'expire.

cpp

    struct itimerspec timer_spec;
    timer_spec.it_value.tv_sec = VOTRE_DELAI; // Réinitialisez le timer à votre délai d'inactivité souhaité
    timer_spec.it_value.tv_nsec = 0;
    timer_spec.it_interval.tv_sec = 0;
    timer_spec.it_interval.tv_nsec = 0;

    timerfd_settime(conn->timer_fd, 0, &timer_spec, NULL);

En utilisant cette approche, chaque connexion active aura son propre timer associé. Si une connexion reste inactive pendant plus longtemps que le délai spécifié, le timer expirera, ce qui vous permettra de prendre des mesures comme la fermeture de la connexion.

//Le nombre de client qu'on souhaite gerer j'ai mis 2 cela depend du trafic que notre reseau va gerer si beaucoup de trafic
// il vaut mieux un nombre eleve si probleme on monte le nombre inon peut etre file d'attente. nfds c'est le nombre d'evenement qui on un truc EPOLLIN etc...
//Peut etre ajouter un timer pour chaque socket pour les closes si pas d'activite recu